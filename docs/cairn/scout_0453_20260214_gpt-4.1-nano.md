<!-- Chasqui Scout Tensor
     Run: 453
     Model: openai/gpt-4.1-nano (OpenAI: GPT-4.1 Nano)
     Cost: prompt=$1e-07/M, completion=$4e-07/M
     Usage: {'prompt_tokens': 839, 'completion_tokens': 430, 'total_tokens': 1269, 'cost': 0.0002559, 'is_byok': False, 'prompt_tokens_details': {'cached_tokens': 0}, 'cost_details': {'upstream_inference_cost': 0.0002559, 'upstream_inference_prompt_cost': 8.39e-05, 'upstream_inference_completions_cost': 0.000172}, 'completion_tokens_details': {'reasoning_tokens': 0, 'image_tokens': 0}}
     Timestamp: 2026-02-14T08:25:25.973664+00:00
-->

### Verdict
CONFIRMED

### Evidence
- The docstring of the `correct` function states:  
  `"Correct a prior claim. Original is preserved â€” always queryable."`
- The function creates a `CorrectionRecord` object with fields including `original_claim` and `corrected_claim`:  
  ```python
  correction = CorrectionRecord(
      target_tensor=target_tensor,
      target_strand_index=target_strand_index,
      target_claim_id=target_claim_id,
      original_claim=original_claim,
      corrected_claim=corrected_claim,
      evidence=evidence,
      provenance=prov,
  )
  ```
- The function then calls `interface.store_correction(correction)` to store this correction record.
- Additionally, if `correcting_tensor` is provided, it creates a `CompositionEdge` of relation type `corrects`:
  ```python
  edge = CompositionEdge(
      from_tensor=correcting_tensor,
      to_tensor=target_tensor,
      relation_type=RelationType.CORRECTS,
      provenance=prov,
  )
  interface.store_composition_edge(edge)
  ```
- The function's docstring states:  
  `"Creates both a CorrectionRecord and a CompositionEdge (type=corrects)."`

### Reasoning
The code explicitly creates a `CorrectionRecord` that preserves both the original and corrected claims, aligning with the claim that it "records corrections and automatically creates a correction edge." Furthermore, it creates a `CompositionEdge` with relation type `corrects` when `correcting_tensor` is provided, confirming the claim about automatically creating a correction edge. The docstring and the actual code behavior support the assertion that `correct.py` handles corrections by creating both a correction record and a correction edge.

### Declared Losses
I cannot verify how the `interface.store_correction` or `interface.store_composition_edge` methods behave at runtime, but their invocation aligns with the claim about recording and creating edges. The code itself confirms the creation of these objects and their storage calls.

---
**Final judgment: The claim is supported by the source code.**