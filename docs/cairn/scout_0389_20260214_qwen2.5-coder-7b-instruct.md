<!-- Chasqui Scout Tensor
     Run: 389
     Model: qwen/qwen2.5-coder-7b-instruct (Qwen: Qwen2.5 Coder 7B Instruct)
     Cost: prompt=$3e-08/M, completion=$9e-08/M
     Usage: {'prompt_tokens': 4213, 'completion_tokens': 2048, 'total_tokens': 6261, 'cost': 0.00031071, 'is_byok': False, 'prompt_tokens_details': {'cached_tokens': 0, 'audio_tokens': 0}, 'cost_details': {'upstream_inference_cost': 0.00031071, 'upstream_inference_prompt_cost': 0.00012639, 'upstream_inference_completions_cost': 0.00018432}, 'completion_tokens_details': {'reasoning_tokens': 0, 'audio_tokens': 0}}
     Timestamp: 2026-02-14T01:08:28.132979+00:00
-->

# Verification Assignment

## The Claim

Model `arcee-ai/trinity-mini` made this claim about `.claude/hooks/chasqui_pulse.py`:

> **File Inspection**: The provided file (`chasqui_pulse.py`) contains no references to `chasqui_heartbeat.sh`.

## The File

Here is the actual content of `.claude/hooks/chasqui_pulse.py`:

```
#!/usr/bin/env python3
"""Chasqui pulse — the reactive heartbeat.

Runs frequently via cron (every 1-5 minutes). Mostly does nothing.
Wakes up when:
  - Code changed (new commits since last check) → dispatch a scout
  - 30 minutes since last scout → dispatch one anyway (minimum heartbeat)
  - Every 3rd heartbeat → queue a scour (periodic exploration)
  - New cairn files sitting uncommitted → digest (auto-commit)
  - Work queue has items → process the next one

The work queue is the living part. Scouts create verify items.
Verifications with DENIED verdicts create respond items. Periodic
scours explore code modules and tensors. The digest step commits
new reports to git so the cairn stays clean. The system generates
its own work.

State lives in .claude/heartbeat_state.json (not committed).
Work queue lives in .claude/work_queue.json (not committed).

Install:
    crontab -e
    * * * * * cd /home/tony/projects/yanantin && uv run python .claude/hooks/chasqui_pulse.py >> logs/chasqui.log 2>&1
"""

from __future__ import annotations

import fcntl
import json
import os
import subprocess
import sys
import time
from datetime import datetime, timezone
from pathlib import Path

PROJECT_DIR = Path(__file__).resolve().parents[2]
UV_BIN = Path.home() / ".local" / "bin" / "uv"
ENV_FILE = PROJECT_DIR / ".env"


def _load_env() -> None:
    """Load .env file into os.environ. Stdlib only, no dotenv dependency."""
    if not ENV_FILE.is_file():
        return
    for line in ENV_FILE.read_text(encoding="utf-8").splitlines():
        line = line.strip()
        if not line or line.startswith("#") or "=" not in line:
            continue
        key, _, value = line.partition("=")
        key = key.strip()
        value = value.strip().strip("'\"")
        if key and key not in os.environ:
            os.environ[key] = value
STATE_FILE = PROJECT_DIR / ".claude" / "heartbeat_state.json"
QUEUE_FILE = PROJECT_DIR / ".claude" / "work_queue.json"
LOCK_FILE = PROJECT_DIR / ".claude" / ".pulse.lock"
LOG_DIR = PROJECT_DIR / "logs"

# Intervals in seconds
MIN_SCOUT_INTERVAL = 300       # 5 minutes between scouts
HEARTBEAT_INTERVAL = 1800      # 30 minutes — debugging frequency (was 6 hours)
SCOUR_EVERY_N_HEARTBEATS = 3   # Queue a scour every 3rd heartbeat
DIGEST_INTERVAL = 300          # 5 minutes between cairn commits (batch reports)

# Scour targets — (target_path, scope) pairs for periodic exploration
SCOUR_TARGETS = [
    ("src/yanantin/apacheta", "introspection"),
    ("src/yanantin/chasqui", "introspection"),
    ("src/yanantin/awaq", "introspection"),
    ("src/yanantin/tinkuy", "introspection"),
    ("T*", "tensor"),
    ("scout_*", "synthesis"),
]


def log(msg: str) -> None:
    ts = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
    print(f"[{ts}] {msg}", flush=True)


def load_json(path: Path, default: dict | list) -> dict | list:
    if path.exists():
        try:
            return json.loads(path.read_text(encoding="utf-8"))
        except (json.JSONDecodeError, OSError):
            pass
    return default


def save_json(path: Path, data: dict | list) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(json.dumps(data, indent=2, default=str), encoding="utf-8")


def current_commit() -> str:
    """Get the current HEAD commit hash."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "HEAD"],
            capture_output=True, text=True, cwd=PROJECT_DIR,
        )
        return result.stdout.strip()
    except (subprocess.SubprocessError, OSError):
        return ""


def commits_since(old_hash: str) -> list[str]:
    """Get commit hashes between old_hash and HEAD."""
    if not old_hash:
        return []
    try:
        result = subprocess.run(
            ["git", "rev-list", f"{old_hash}..HEAD"],
            capture_output=True, text=True, cwd=PROJECT_DIR,
        )
        return [h for h in result.stdout.strip().split("\n") if h]
    except (subprocess.SubprocessError, OSError):
        return []


def code_changed(commits: list[str]) -> bool:
    """Check if any of the commits touched src/ or tests/."""
    for commit in commits:
        try:
            result = subprocess.run(
                ["git", "diff-tree", "--no-commit-id", "--name-only", "-r", commit],
                capture_output=True, text=True, cwd=PROJECT_DIR,
            )
            for f in result.stdout.strip().split("\n"):
                if f.startswith("src/") or f.startswith("tests/"):
                    return True
        except (subprocess.SubprocessError, OSError):
            pass
    return False


def run_tinkuy_check() -> tuple[bool, str]:
    """Run tinkuy --check to verify blueprint accuracy.

    Returns (passed, output_text).
    """
    cmd = [str(UV_BIN), "run", "python", "-m", "yanantin.tinkuy", "--check"]
    try:
        result = subprocess.run(
            cmd, capture_output=True, text=True, cwd=PROJECT_DIR,
            timeout=60,
        )
        output = result.stdout + result.stderr
        passed = result.returncode == 0
        return passed, output.strip()
    except (subprocess.SubprocessError, OSError) as e:
        return False, f"tinkuy check failed to run: {e}"


AI_GIT_CONFIG = [
    "-c", "user.name=Yanantin AI (Claude Opus)",
    "-c", "user.email=yanantin@wamason.com",
    "-c", "user.signingkey=1E416B1FB63AF88179EE0F38D0CAB9659C950893",
]


def digest_cairn() -> int:
    """Auto-commit new/modified cairn files. Returns count committed."""
    try:
        result = subprocess.run(
            ["git", "status", "--porcelain", "docs/cairn/"],
            capture_output=True, text=True, cwd=PROJECT_DIR,
        )
    except (subprocess.SubprocessError, OSError):
        return 0

    lines = [ln for ln in result.stdout.strip().split("\n") if ln.strip()]
    if not lines:
        return 0

    # Categorize for commit message
    scouts = sum(1 for ln in lines if "scout_" in ln)
    scours = sum(1 for ln in lines if "scour_" in ln)
    compactions = sum(1 for ln in lines if "compaction" in ln)
    other = len(lines) - scouts - scours - compactions

    parts = []
    if scouts:
        parts.append(f"{scouts} scout{'s' if scouts != 1 else ''}")
    if scours:
        parts.append(f"{scours} scour{'s' if scours != 1 else ''}")
    if compactions:
        parts.append(f"{compactions} compaction{'s' if compactions != 1 else ''}")
    if other:
        parts.append(f"{other} other")
    summary = ", ".join(parts) or f"{len(lines)} files"

    try:
        subprocess.run(
            ["git", "add", "docs/cairn/"],
            cwd=PROJECT_DIR, check=True,
        )
        subprocess.run(
            ["git"] + AI_GIT_CONFIG + ["commit", "-S", "-m", f"Cairn digest: {summary}"],
            cwd=PROJECT_DIR, check=True,
        )
        log(f"Cairn digest committed: {summary}")
        return len(lines)
    except (subprocess.SubprocessError, OSError) as e:
        log(f"Cairn digest commit failed: {e}")
        return 0


def enqueue(queue: list, item: dict) -> list:
    """Add an item to the queue if no duplicate type+trigger exists."""
    for existing in queue:
        if existing.get("type") == item.get("type") and existing.get("trigger") == item.get("trigger"):
            return queue  # Already queued
    queue.append(item)
    return queue


def dispatch_chasqui(mode: str, extra_args: list[str] | None = None) -> dict | None:
    """Run Chasqui and return parsed JSON output."""
    cmd = [str(UV_BIN), "run", "python", "-m", "yanantin.chasqui