<!-- Chasqui Scout Tensor
     Run: 130
     Model: qwen/qwen2.5-coder-7b-instruct (Qwen: Qwen2.5 Coder 7B Instruct)
     Cost: prompt=$3e-08/M, completion=$9e-08/M
     Usage: {'prompt_tokens': 4515, 'completion_tokens': 2048, 'total_tokens': 6563, 'cost': 0.00031977, 'is_byok': False, 'prompt_tokens_details': {'cached_tokens': 0, 'audio_tokens': 0}, 'cost_details': {'upstream_inference_cost': 0.00031977, 'upstream_inference_prompt_cost': 0.00013545, 'upstream_inference_completions_cost': 0.00018432}, 'completion_tokens_details': {'reasoning_tokens': 0, 'audio_tokens': 0}}
     Timestamp: 2026-02-12T20:18:15.348377+00:00
-->

# Verification Assignment

## The Claim

Model `meta-llama/llama-3.1-8b-instruct` made this claim about `tests/unit/test_memory_backend.py`:

> The tests, such as `test_get_strand_shares_source_uuid` in `tests/unit/test_memory_backend.py`, enforce this immutability by raising `ImmutabilityError` on attempted modifications.

## The File

Here is the actual content of `tests/unit/test_memory_backend.py`:

```
"""Unit tests for the in-memory backend."""

from datetime import datetime
import threading
from uuid import uuid4

import pytest

from yanantin.apacheta.backends.memory import InMemoryBackend
from yanantin.apacheta.interface.errors import ImmutabilityError, NotFoundError
from yanantin.apacheta.models import (
    BootstrapRecord,
    CompositionEdge,
    CorrectionRecord,
    DeclaredLoss,
    DissentRecord,
    EntityResolution,
    EpistemicMetadata,
    KeyClaim,
    LossCategory,
    NegationRecord,
    ProvenanceEnvelope,
    RelationType,
    SchemaEvolutionRecord,
    StrandRecord,
    TensorRecord,
)


@pytest.fixture
def backend():
    return InMemoryBackend()


@pytest.fixture
def sample_tensor():
    return TensorRecord(
        provenance=ProvenanceEnvelope(
            author_model_family="claude",
            timestamp=datetime(2026, 2, 7),
        ),
        preamble="Test tensor",
        strands=[
            StrandRecord(
                strand_index=0,
                title="Test Strand",
                topics=["testing"],
                key_claims=[
                    KeyClaim(
                        text="Tests validate correctness",
                        epistemic=EpistemicMetadata(truth=0.95),
                    ),
                ],
            ),
        ],
        lineage_tags=["test-sequence"],
    )


def _make_tensor():
    return TensorRecord(
        provenance=ProvenanceEnvelope(
            author_model_family="claude",
            timestamp=datetime(2026, 2, 7),
        ),
        preamble="Copy check tensor",
        strands=[
            StrandRecord(
                strand_index=0,
                title="Copy Strand",
                topics=["copying"],
                key_claims=[
                    KeyClaim(
                        text="Copies should be isolated",
                        epistemic=EpistemicMetadata(truth=0.9),
                    ),
                ],
            ),
        ],
        lineage_tags=["copy-tests"],
    )


def _make_edge():
    return CompositionEdge(
        from_tensor=uuid4(),
        to_tensor=uuid4(),
        relation_type=RelationType.COMPOSES_WITH,
    )


class TestStoreAndRetrieve:
    def test_store_and_get_tensor(self, backend, sample_tensor):
        backend.store_tensor(sample_tensor)
        retrieved = backend.get_tensor(sample_tensor.id)
        assert retrieved.id == sample_tensor.id
        assert retrieved.preamble == "Test tensor"

    def test_list_tensors(self, backend, sample_tensor):
        assert backend.list_tensors() == []
        backend.store_tensor(sample_tensor)
        tensors = backend.list_tensors()
        assert len(tensors) == 1
        assert tensors[0].id == sample_tensor.id

    def test_get_strand(self, backend, sample_tensor):
        backend.store_tensor(sample_tensor)
        result = backend.get_strand(sample_tensor.id, 0)
        assert len(result.strands) == 1
        assert result.strands[0].title == "Test Strand"

    def test_get_strand_shares_source_uuid(self, backend, sample_tensor):
        source_tensor = sample_tensor.model_copy(
            update={
                "strands": sample_tensor.strands
                + (
                    StrandRecord(
                        strand_index=1,
                        title="Second Strand",
                        topics=["testing"],
                        key_claims=[
                            KeyClaim(
                                text="Views keep provenance intact",
                                epistemic=EpistemicMetadata(truth=0.9),
                            ),
                        ],
                    ),
                )
            }
        )
        backend.store_tensor(source_tensor)
        strand_tensor = backend.get_strand(source_tensor.id, 0)

        assert strand_tensor.id == source_tensor.id
        assert len(source_tensor.strands) == 2
        assert len(strand_tensor.strands) == 1

        with pytest.raises(ImmutabilityError):
            backend.store_tensor(strand_tensor)

    def test_get_nonexistent_tensor(self, backend):
        with pytest.raises(NotFoundError):
            backend.get_tensor(uuid4())

    def test_get_nonexistent_strand(self, backend, sample_tensor):
        backend.store_tensor(sample_tensor)
        with pytest.raises(NotFoundError):
            backend.get_strand(sample_tensor.id, 99)


class TestCompositionEdgeStorage:
    def test_store_and_query_edges(self, backend):
        t_a, t_b = uuid4(), uuid4()
        edge = CompositionEdge(
            from_tensor=t_a,
            to_tensor=t_b,
            relation_type=RelationType.COMPOSES_WITH,
        )
        backend.store_composition_edge(edge)
        graph = backend.query_composition_graph()
        assert len(graph) == 1
        assert graph[0].from_tensor == t_a

    def test_bridge_query(self, backend):
        edge = CompositionEdge(
            from_tensor=uuid4(),
            to_tensor=uuid4(),
            relation_type=RelationType.COMPOSES_WITH,
            authored_mapping="Theory maps to practice via...",
        )
        backend.store_composition_edge(edge)
        bridges = backend.query_bridges()
        assert len(bridges) == 1


class TestCorrectionStorage:
    def test_store_correction(self, backend):
        claim_id = uuid4()
        corr = CorrectionRecord(
            target_tensor=uuid4(),
            target_claim_id=claim_id,
            original_claim="Entropy measures truth",
            corrected_claim="Entropy measures familiarity",
        )
        backend.store_correction(corr)
        chain = backend.query_correction_chain(claim_id)
        assert len(chain) == 1
        assert chain[0].corrected_claim == "Entropy measures familiarity"

    def test_epistemic_status_after_correction(self, backend):
        claim_id = uuid4()
        corr = CorrectionRecord(
            target_tensor=uuid4(),
            target_claim_id=claim_id,
            original_claim="Old claim",
            corrected_claim="New claim",
        )
        backend.store_correction(corr)
        status = backend.query_epistemic_status(claim_id)
        assert status["current_claim"] == "New claim"
        assert status["correction_count"] == 1


class TestDissentAndNegation:
    def test_store_dissent(self, backend):
        dissent = DissentRecord(
            target_tensor=uuid4(),
            alternative_framework="Field topology",
            reasoning="Continuous > discrete",
        )
        backend.store_dissent(dissent)
        disagreements = backend.query_disagreements()
        assert any(d["type"] == "dissent" for d in disagreements)

    def test_store_negation(self, backend):
        neg = NegationRecord(
            tensor_a=uuid4(),
            tensor_b=uuid4(),
            reasoning="Different lineages",
        )
        backend.store_negation(neg)
        disagreements = backend.query_disagreements()
        assert any(d["type"] == "negation" for d in disagreements)


class TestBootstrapAndEvolution:
    def test_store_bootstrap(self, backend):
        boot = BootstrapRecord(
            instance_id="test-instance",
            context_budget=0.80,
            task="Testing",
        )
        backend.store_bootstrap(boot)
        counts = backend.count_records()
        assert counts["bootstraps"] == 1

    def test_store_evolution(self, backend):
        evo = SchemaEvolutionRecord(
            from_version="v1",
            to_version="v2",
            fields_added=["functional_spec"],
        )
        backend.store_evolution(evo)
        counts = backend.count_records()
        assert counts["evolutions"] == 1


class TestEntityResolutionStorage:
    def test_store_entity(self, backend):
        entity = EntityResolution(
            entity_uuid=uuid4(),
            identity_type="ai_instance",
            identity_data={"model": "claude"},
        )
        backend.store_entity(entity)
        counts = backend.count_records()
        assert counts["entities"] == 1

    def test_get_entity_roundtrip(self, backend):
        entity = EntityResolution(
            entity_uuid=uuid4(),
            identity_type="ai_instance",
            identity_data={"model": "claude-3-opus"},
        )
        backend.store_entity(entity)

        retrieved = backend.get_entity(entity.id)

        assert retrieved.id == entity.id
        assert retrieved.entity_uuid == entity.entity_uuid
        assert retrieved.identity_data["model"] == "claude-3-opus"

    def test_get_entity_not_found(self, backend):
        with pytest.raises(NotFoundError):
            backend.get_entity(uuid4())

    def test_query_entities_by_uuid(self, backend):
        shared_uuid = uuid4()
        entity_a = EntityResolution(
            entity_uuid=shared_uuid,
            identity_type="ai_instance",
            identity_data={"label": "first"},
        )
        entity_b = EntityResolution(
            entity_uuid=shared_uuid,
            identity_type="ai_instance",
            identity_data={"label": "second"},
        )
        backend.store_entity(entity_a)
        backend.store_entity(entity_b)

        matches = backend.query_entities_by_uuid(shared_uuid)

        assert {match.id for match in matches} == {entity_a.id, entity_b.id}

    def test_query_entities_by_uuid_empty(self, backend):
        matches = backend.query_entities_by_uuid(uuid4())

        assert matches == []


class TestQueryOperations:
    def test_query_claims_about(self, backend, sample_tensor):
        backend.store_tensor(sample_tensor)
        claims = backend.query_claims_about("testing")
        assert len(claims) == 1
        assert "Tests validate correctness" in claims[0