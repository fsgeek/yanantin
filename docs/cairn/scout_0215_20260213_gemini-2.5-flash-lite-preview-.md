<!-- Chasqui Scout Tensor
     Run: 215
     Model: google/gemini-2.5-flash-lite-preview-09-2025 (Google: Gemini 2.5 Flash Lite Preview 09-2025)
     Cost: prompt=$1e-07/M, completion=$4e-07/M
     Usage: {'prompt_tokens': 787, 'completion_tokens': 631, 'total_tokens': 1418, 'cost': 0.0003311, 'is_byok': False, 'prompt_tokens_details': {'cached_tokens': 0, 'cache_write_tokens': 0, 'audio_tokens': 0, 'video_tokens': 0}, 'cost_details': {'upstream_inference_cost': 0.0003311, 'upstream_inference_prompt_cost': 7.87e-05, 'upstream_inference_completions_cost': 0.0002524}, 'completion_tokens_details': {'reasoning_tokens': 0, 'image_tokens': 0}}
     Timestamp: 2026-02-13T06:11:15.375680+00:00
-->

### Verdict
INDETERMINATE

### Evidence
The file content is:
```python
"""Compose operator — creates composition edges between tensors.

Bridge = Compose with authored_mapping populated. Single operator,
two modes.
"""

from __future__ import annotations

from uuid import UUID

from yanantin.apacheta.interface.abstract import ApachetaInterface
from yanantin.apacheta.models.composition import CompositionEdge, RelationType
from yanantin.apacheta.models.provenance import ProvenanceEnvelope


def compose(
    interface: ApachetaInterface,
    from_tensor: UUID,
    to_tensor: UUID,
    *,
    ordering: int = 0,
    authored_mapping: str | None = None,
    provenance: ProvenanceEnvelope | None = None,
) -> CompositionEdge:
    """Create a composition edge between two tensors.

    If authored_mapping is provided, this is a bridge composition —
    the mapping describes how strands/claims relate across tensors.

    Composition is non-commutative: compose(A, B) != compose(B, A).
    """
    edge = CompositionEdge(
        from_tensor=from_tensor,
        to_tensor=to_tensor,
        relation_type=RelationType.COMPOSES_WITH,
        ordering=ordering,
        authored_mapping=authored_mapping,
        provenance=provenance or ProvenanceEnvelope(),
    )
    interface.store_composition_edge(edge)
    return edge
```

### Reasoning
The claim states that operators such as `compose.py` handle schema changes and disagreements formally. The provided file is `compose.py`. The file itself shows that `compose` optionally accepts an `authored_mapping` argument, and the docstring states: "If authored_mapping is provided, this is a bridge composition — the mapping describes how strands/claims relate across tensors." This suggests a mechanism for defining relationships (which could relate to schema disagreements or structural changes). However, the code only shows the *creation* of a `CompositionEdge`. It does not show the actual logic for *handling* schema changes or *resolving* disagreements formally; it only shows the mechanism for *recording* a composition relationship that might involve such a mapping. Since I cannot see the definition or usage of `correct.py` or `evolve.py`, and the evidence for `compose.py` only shows recording a mapping rather than formal handling/resolution logic, I cannot confirm the entirety of the claim.

### Declared Losses
I cannot confirm whether `correct.py` and `evolve.py` handle schema changes formally, as only the content of `compose.py` was provided. Furthermore, I cannot confirm that `compose.py` handles schema changes *formally*; it only records a composition edge using an optional `authored_mapping` string, the formal definition/handling of which is external to this function's scope.